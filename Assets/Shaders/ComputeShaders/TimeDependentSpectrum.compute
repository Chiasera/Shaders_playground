// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel TimeDependentSpectrum
#include "ComplexOperations.hlsl"

static const float PI = 3.1415926;
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> H0;
RWTexture2D<float4> WavesData; //stores the position of the wave, the magnitude of the vector wave, and frequency 
RWTexture2D<float2> Dx_Dz;
RWTexture2D<float2> Dy_Dxz;
RWTexture2D<float2> Dyx_Dyz;
RWTexture2D<float2> Dxx_Dzz;
//RWTexture2D<float4> HK_DZ;
/* 
    Data we retrieve from the renderTexture generated by the WaveSpectrum compute shader
    h_k is stored in the red and green channels and h_minus_k_conj  is stored in the blue and alpha channels 
    So h_k = H0.xy and h_minus_k_conj = H0.zw
*/
float t; //time
float N; //grid size
float L; //Simulation scale

[numthreads(8,8,1)]
void TimeDependentSpectrum(uint3 id : SV_DispatchThreadID)
{
    float4 wave = WavesData[id.xy];
    float2 h_k = H0[id.xy].xy;
    float2 h_minus_k_conj = H0[id.xy].zw;
    float phase = WavesData[id.xy].w * t; //frequency multiplied by time
    float2 h_t = ComplexMult(H0[id.xy].xy, EulerExp(phase))
		+ ComplexMult(H0[id.xy].zw, EulerExp(-phase));
    
    float2 ih = float2(-h_t.y, h_t.x);
    
    float2 displacementX = ih * wave.x * wave.y;
    float2 displacementY = h_t;
    float2 displacementZ = ih * wave.z * wave.y;
		 
    float2 displacementX_dx = -h_t * wave.x * wave.x * wave.y;
    float2 displacementY_dx = ih * wave.x;
    float2 displacementZ_dx = -h_t * wave.x * wave.z * wave.y;
		 
    float2 displacementY_dz = ih * wave.z;
    float2 displacementZ_dz = -h_t * wave.z * wave.z * wave.y;    
    
    Dx_Dz[id.xy] = float2(displacementX.x - displacementZ.y, displacementX.y + displacementZ.x);
    Dy_Dxz[id.xy] = float2(displacementY.x - displacementZ_dx.y, displacementY.y + displacementZ_dx.x);
    Dyx_Dyz[id.xy] = float2(displacementY_dx.x - displacementY_dz.y, displacementY_dx.y + displacementY_dz.x);
    Dxx_Dzz[id.xy] = float2(displacementX_dx.x - displacementZ_dz.y, displacementX_dx.y + displacementZ_dz.x);
    
}  
